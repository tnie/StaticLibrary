静态库项目：lib1、lib2
可执行程序：main

lib2 使用了 lib1 的头文件，但未打包 lib1 的静态库。—— 打包静态库时，只需要声明，不需要实现的吗？—— 是的呀
所以，编译 main 需要同时给出 lib1、lib2 两者的静态库！

# 一起打包

当然，我们也可以将 lib1 静态库打包进 lib2 静态库。这样的话，编译 main 就只需要 lib2 静态库就可以了。

# 菱形依赖，“基石”跨版本

“基石”跨版本，等价于相同接口，不同实现。

```cpp
#pragma comment(lib, "../Debug/lib1.lib")
#pragma comment(lib, "../Debug/lib2.lib")
int main()
{
    cout << add("niel ", "lov") << endl;	// lib2
    cout << append("niel ", "lov") << endl;
}
```

试验现象：引用链接库的顺序会直接影响输出结果（需要**清理项目，重新生成**才能看到结果变化，因为改变预处理指令 `#pragma comment` 顺序不会重新链接）

```console
# 首先链接 lib1.lib
[used by main]niel lov
[used by main]niel lov
```

```console
# 首先链接 lib2.lib
Version 0.1[ used by lib2]: niel lov
Version 0.1[ used by lib2]: niel lov
```

不会出现代码暗示的下述输出
```console
Version 0.1[ used by lib2]: niel lov
[used by main]niel lov
```

试验 demo 非常简单，不保证在复杂的编译环境中能够复现上述现象。

# MSVC 静态库

如果打包静态库时，我们用到第三方静态库库。我们似乎有两种选择：
1. 将第三方静态库一起打包，只提供给用户一个静态库文件即可。/ [VC 合并静态库](https://blog.csdn.net/atceedsun/article/details/40084245)

	> 使用静态库的两种方式：`#pragma comment(lib, "test.lib")` 指令与直接将 test.lib 添加到 Additional Dependencies 里面是有区别的。前者只是生存了一个 link 指令，并没有将 test.lib 的代码复制进最终生成的静态库里面；而后者则是直接将 test.lib 中的代码复制到了最终生成的静态库里面，所以使用后者生成的静态库时，就不需要再去链接 test.lib 了。


2. 只打包我们自己开发的源码，同时提供多个静态库文件（所有用到的第三方静态库文件）。ps 打包静态库时只需要依赖的三方头文件中的声明，三方依赖库的实现（即静态库）不是必需的！

前者方便用户使用，相比后者在这方面是一个巨大的优势。但前者菱形依赖会出现混乱，类似 C++ 的多重继承会碰到的，所以 C++ 引入了虚继承。

比如在给数据下载项目中，给 guxj 提供的 YDData2.dll 中是封装了 protobuf 的静态库的，而在获取数据之后生成文件时，也需要用到 protobuf 静态库，因为前者封在了 dll 内部，所以此时并未出现冲突（不知道这个分析对不对？还是因为操作很少没踩到雷而已？）

两种方案遇到菱形依赖有时要面临相同的问题：第三方静态库存在全局静态变量怎么处理。

但前者有个更大的问题：至少两份拷贝，究竟用的哪一个呢
1. 同一静态库版本不一致问题；
2. 相同接口不同实现；——这个一般不会造成问题。

上述问题都是炸弹，统一打包成单个静态库看似能够给用户带来便利，但保不齐用户需要使用相同的第三方静态库：
1. 用户不知道你的静态库封了哪些第三方，自己又加了一遍，造成重复；
2. 如果两者版本不一致，那么到底用的哪一个呢？可能造成程序崩溃，也可能不崩溃但未执行预期库，未报错可执行结果就是不对
3. 用户知道你封装了三方静态库 libX，他打算直接用——可是优秀的封装应该只暴露接口，引用的头文件和库文件**应该是收敛的而非发散**的——所以，你替补提供三方库的头文件呢？

	不得已还是要提供的！因为用你的静态库却要用户自己找头文件，这很不合理。

所以，收敛不成，只能发散。

所以，制作静态库时，依赖的三方静态库避免统一打包。比如 chengxy 给 guxj 提供的由原始数据计算除复权的接口，需要 xj 在工程中额外引入 grpc 的头文件以及库文件。

如果只是小范围使用，确保用户并不会用到相同的三方库，可以统一打包，方便调用。可静态库扔出去给人用，还能限制别人怎么用啊

梳理一遭，发现如果大家共享开发环境，静态库的缺点就能避免。可是如果开发环境各异，为了用某个静态库接口，再配置一堆的三方依赖，好恶心。此时，使用动态库是否能够让用户“轻装上阵”呢？

# MSVC 动态库